---
title: 数据库复习
date: 2022-06-19 00:00:00
cover: https://img.hawa130.com/数据库.png
tags: 复习
categories: 学习 
mathjax: true
---

## 题型

单选：10 个 × 2 分

填空：10 个 × 1 分

综合应用题：3 个，每个 10-30 分（考察 2-6 章知识点，重点为关系代数和 sql 语句）

## 第二章 关系数据库

### 关系数据结构及形式化定义

1. 域：概念上等同于集合
2. 笛卡尔积：几个集合取乘积（类似于乘法分配律）所得的集合，不能有重复元素
3. 基数：一个域中的不同元素的个数叫做域的基数
4. 关系：若干个域的笛卡尔积的子集叫做域上的关系，写为 $R(D~1~,D~2~,\ldots ,D~n~)$，其中 n 叫做关系的目或者度
5. 候选码：关系中某一属性组能唯一标识一个元组，而其子集不能，这个属性组叫做候选码。（不能有重复的取值）
6. 主码：一个关系有多个候选码时，选定其中一个为主码。候选码的诸属性叫主属性
7. 关系的三种类型：基本关系（基本表），查询表，视图表
8. 表中不能有小表
9. 关系模式：$R(U,D,DOM)$

### 关系操作

1. 基本的关系操作：
   + 查询（前五种为五种基本操作）
     + 选择
     + 投影
     + 并
     + 差
     + 笛卡尔积
     + 连接
     + 除
     + 交
   + 插入、删除、修改

### 关系的完整性

1. 实体完整性：主属性不能取空值
2. 参照完整性：
   + F 是关系 R 的属性但不是码，K 是关系 S 的主码，如果 F 和 K 相对应，则 F 是关系 R 的外码，称 R 是参照关系，S 是被参照关系。R、S 可以是同一关系。
   + F 是关系 R 的外码，则 F 的各个取值或者取空值，或者等于 S 中对应的值
3. 用户定义的完整性

### 关系代数

1. 用对关系的运算表达查询

2. 传统的集合运算

   + 并 $R \cup S$，两集合取并集
   + 差  $R - S$，属于 R 但不属于 S
   + 交 $R \cap S$，两集合取交集
   + 笛卡尔积 $R \times S$

3. 专门的关系运算

   + 选择（限制）：在关系R中选择满足给定条件的诸元组，$\sigma _F(R)$（例如，$\sigma _{Sdept='IS'}(student)$），其中F表示选择条件。是从行的角度进行的运算。

   + 投影：从关系R中选择出若干属性列组成新的关系，$\pi _A(R)$（例如，$\pi _{Sname}(student)$），其中 A 是 R 的属性列，结果应取消相同行。是从列的角度进行运算。

   + 连接：从两个关系的笛卡尔积里选择满足关系的元组，$R \underset{A\theta B}\Join S$，其中 $\theta$ 为比较运算符。

     + 等值连接：当 $\theta$ 为 ”$=$“ 时
       + 自然连接：特殊的等值连接，进行比较的分量必须是同名的属性组，并在结果中取消重复列。同时从行和列的角度进行运算。
     + 外连接
       + 悬浮元组：自然连接运算中被舍弃的元组
       + 外连接：把悬浮元组也保存在结果关系中，在其他属性填 $NULL$，$R\ ⟗\ S$
         + 左外连接：只保留左边关系 R 的悬浮元组，$R\ ⟕\ S$
         + 右外连接：只保留左边关系 S 的悬浮元组，$R\ ⟖\ S$

   + 除：$R\div S=T$，$T$ 包含在 R 但不在 S 中的属性及其值。同时从行和列的角度进行运算。

     类似于在两关系的共同属性上一一对照，找到左边关系中含右边关系的所有非共同属性的非共同属性，即为运算结果。

## 第三章 关系数据库标准语言 SQL

### 概述

1. SQL 的特点
   + 综合统一
     + SQL 集==数据定义==语言、==数据操纵==语言、==数据控制==语言、==数据查询==语言的功能于一体
   + 高度非过程化
   + 面向集合的操作方式
   + 提供多种使用方式
   + 语言简洁，易学易用

### 数据定义

1. 模式

   + 定义

     ```sql
     create schema <模式名> authorization <用户名>
     ```

     ![image-20220621145809959](https://img.hawa130.com/image-20220621145809959.png)

   + 删除

     ```sql
     drop schema <模式名><cascade（级联）|restrict（限制）>
     ```

     级联和限制必选其一，级联表示把该模式的数据库对象全部删除；限制表示如果已经该模式中如果已经定义了下属的数据库对象，就拒绝该语句的执行。

     ![image-20220621145833629](https://img.hawa130.com/image-20220621145833629.png)

   + 常用完整性约束

     ![image-20220621150948118](https://img.hawa130.com/image-20220621150948118.png)

2. 基本表

   + ![image-20220621145727498](https://img.hawa130.com/image-20220621145727498.png)

   + 定义表

     ```sql
     create table <表名> (<列名><数据类型> [列级完整约束条件]							...
     					[，<表级完整约束条件>]);
     ```

   + 删除表

     ```sql
     drop table <表名> [restrict|cascade]; 
     ```

     + restrict：删除表有限制条件。欲删除的基本表不能被其他表的约束所引用，如果存在依赖该表的对象，则此表不能被删除。 默认是 restrict。
     + cascade：删除表没有限制条件。在删除基本表的同时，相关的依赖对象一起删除 

     ![image-20220621152410203](https://img.hawa130.com/image-20220621152410203.png)

   + 模式与表

     + 表中给出模式名

       ![image-20220621150534682](https://img.hawa130.com/image-20220621150534682.png)

     + 创建模式语句中同时创建表

       ![image-20220621150618987](https://img.hawa130.com/image-20220621150618987.png)

   + 修改表

     ```sql
     alter table <表名> 
     	[add <新列名> <数据类型> [完整性约束]] 
     	[drop <完整性约束名>] 
     	[alter column <列名> type <数据类]; 
     ```

     ![image-20220621152230609](https://img.hawa130.com/image-20220621152230609.png)

   + 表级完整性约束条件定义

     ![image-20220621151833405](https://img.hawa130.com/image-20220621151833405.png)

3. 索引

   + 分类

     + 普通索引(normal Index)：索引表的 Search-key 项中的每一索引值对应全部取该值的基本表中的记录。普通索引通过索引表的指针项指向一个单链表来实现，该链表的每个结点的数据项指向一条物理记录。 
     + 单一索引(unique Index)：每一个索引值只对应唯一的数据记录。当建立单一索引后，索引项不可以再插入已有值，但可以插入多个空值，这等同于在建表时对索引列增加一个 UNIQUE 约束；同样，当建立单一索引时，如果待索引项存在相同值则不能建立。 
     + 聚簇索引(cluster Index)：索引项顺序与表中数据记录的物理顺序一致。即基本表是按照索引表的 Search-key 项的排列次序组织存储的，因此，一个基本表只能建立一个聚簇索引。

   + 建立索引

     ```sql
     create [unique] | [cluster] index <索引名>
     	on <表名>(<列名>[<次序>][,<列名>[<次序>] ]…) ;
     ```

     + 用表名指定要建索引的基本表名字

     + 索引可以建立在该表的一列或多列上，各列名之间用逗号分隔

     + 用次序指定索引值的排列次序，升序：ASC，降序：DESC；缺省值：ASC

     + unique表明此索引的每一个索引值对应唯一的数据记录

     + cluster表示要建立的索引是聚簇索引

   

  ![image-20220621153010553](https://img.hawa130.com/image-20220621153010553.png)

+ 删除索引
  
  ```sql
     alter table <表名> drop index <索引名>;
  ```
  
  ![image-20220621153246594](https://img.hawa130.com/image-20220621153246594.png)

### 数据查询

1. 单表查询

   + select 语句

     ```sql
     SELECT [ALL | DISTINCT] <目标列表达式> [,<目标列表达式>] … 
     FROM <表名或视图名>[, <表名或视图名> ] … 
     [ WHERE <条件表达式> ] 
     [ GROUP BY <列名1> [ HAVING <条件表达式> ] ] 
     [ ORDER BY <列名2> [ ASC | DESC ] ] ;
     ```

     + select 子句：指定要显示的属性列
     + from 子句：指定查询对象(基本表或视图)
     + where 子句：指定查询条件
     + group by 子句：对查询结果按指定列的值分组，该属性列值相等的元组为一个组。通常会在每组中使用集函数；having 短语：筛选出只有满足指定条件的组
     + order by 子句：对查询结果按指定列值升序或降序排序

   + 选择表中的若干列（$\pi$）

     ![image-20220621154928698](https://img.hawa130.com/image-20220621154928698.png)

   + 查询指定列

   + 查询全部列

     ```sql
     select*
     from <table>;
     ```

   + 查询经过计算的值

     ![image-20220621155135450](https://img.hawa130.com/image-20220621155135450.png)

   + 选择表中的若干元组

   + 消除取值重复的行：distinct

     ![image-20220621155247785](https://img.hawa130.com/image-20220621155247785.png)

   + 查询满足条件的元组：where（$\sigma$）

     + 比较

       ![image-20220621155641853](https://img.hawa130.com/image-20220621155641853.png)

     + 确定范围：between and，not between and

       ![image-20220621155816131](https://img.hawa130.com/image-20220621155816131.png)

     + 确定集合：in，not in

       ![image-20220621155833237](https://img.hawa130.com/image-20220621155833237.png)

     + 字符匹配：like，not like

       + %：任意长度字符串
       + _：任意单个字符

       ![image-20220621155947142](https://img.hawa130.com/image-20220621155947142.png)

     + 涉及空值的查询：is nullI，is not null

       ![image-20220621160118928](https://img.hawa130.com/image-20220621160118928.png)

     + 多重条件（逻辑运算）：and，or，not

       ![image-20220621160240283](https://img.hawa130.com/image-20220621160240283.png)

   + order by 语句

     + 可以按一个或多个属性列排序
       + 升序：ASC
       + 降序：DESC
       + 默认为升序 
     + 当排序列含空值时：将空值作为最大值来理解

     ![image-20220621160610847](https://img.hawa130.com/image-20220621160610847.png)

   + 聚集函数（count，sum，avg，max，min：只能用于 SELECT 语句和 GROUP BY

     ```sql
     计数
     COUNT ([DISTINCT|ALL] *) COUNT ([DISTINCT|ALL] <列名>)
     计算总和
     SUM ([DISTINCT|ALL] <列名>)
     计算平均值
     AVG ([DISTINCT|ALL] <列名>)
     求最大值
     MAX ([DISTINCT|ALL] <列名>)
     求最小值
     MIN ([DISTINCT|ALL] <列名>)
     ```

     ![image-20220621160911225](https://img.hawa130.com/image-20220621160911225.png)

   + GROUP BY 语句

     ![image-20220621161034237](https://img.hawa130.com/image-20220621161034237.png)

2. 连接查询

   + 等值与非等值连接查询

     ![image-20220621162218418](https://img.hawa130.com/image-20220621162218418.png)

     + 自然连接：等值连接中，去掉重复的属性列为自然连接

   + 自身连接

     ![image-20220621162311919](https://img.hawa130.com/image-20220621162311919.png)

   + 外连接

     + 左外连接列出左边关系所有元组
     + 右外连接列出右边关系所有元组

     ![image-20220621162342054](https://img.hawa130.com/image-20220621162342054.png)

   + 多表连接

     ![image-20220621162506142](https://img.hawa130.com/image-20220621162506142.png)

3. 嵌套查询

   + 查询块：一个 select-from-where 语句称为一个查询块 

   + 带有 IN 谓词的子查询

     + 不相关子查询：子查询的查询条件不依赖于父查询（可以用自身连接）
     + 相关子查询：子查询的查询条件依赖于父查询

     ![image-20220621162804315](https://img.hawa130.com/image-20220621162804315.png)

     ![image-20220621162858568](https://img.hawa130.com/image-20220621162858568.png)

   + 带有比较运算符的子查询（比较运算符）

     ![image-20220621162936356](https://img.hawa130.com/image-20220621162936356.png)

   + 带有 ANY（SOME）或 ALL 谓词的子查询（效率低于聚集函数）

     ![image-20220621165645842](https://img.hawa130.com/image-20220621165645842.png)

   + 带有 EXISTS 谓词的子查询，不返回任何值，只产生逻辑真，假

     ![image-20220621165920051](https://img.hawa130.com/image-20220621165920051.png)

     ![image-20220621170225381](https://img.hawa130.com/image-20220621170225381.png)

4. 集合查询

   + 并 union：将多个查询结果合并，自动去掉重复元组
   + 交 intersect
   + 差 except

   ![image-20220621170350062](https://img.hawa130.com/image-20220621170350062.png)

5. 基于派生表的查询

### 数据更新

1. 插入数据

   + 插入元组 INSERT INTO VALUES

     ```sql
     INSERT INTO <表名> [(<属性列1>[，<属性列2 >…)] 
     VALUES (<常量1> [，<常量2>] … ) ;
     ```

     + INTO 子句 
       + 指定要插入数据的表名及属性列 
       + 属性列的顺序可与表定义中的顺序不一致 
       + 没有指定属性列：表示要插入的是一条完整的元组，且属性列属性与表定义中的顺序一致 
       + 指定部分属性列：插入的元组在其余属性列上取空值 
     + VALUES 子句：提供的值的个数和值的类型必须与 INTO 子句匹配

     ![image-20220621170659802](https://img.hawa130.com/image-20220621170659802.png)

   + 插入子查询结果 INSERT INTO 子查询

     ```sql
     INSERT INTO <表名> [(<属性列1> [，<属性列2>… )]
     子查询；
     ```

     + INTO 子句，与插入单条元组类似
     + 子查询，SELECT 子句目标列属性的个数和类型必须与 INTO 子句匹配。

2. 修改数据 UPDATE SET

   + 语法

     ```sql
     UPDATE <表名>
     SET <列名>=<表达式>[, <列名>=<表达式>]…
     [WHERE <条件>]；
     ```

     + SET 子句：指定修改方式，要修改的列和修改后取值 

     + WHERE 子句
       + 指定要修改的元组 
       + 缺省表示要修改表中的所有元组

   + 修改某一个元组的值

     ![image-20220621171031249](https://img.hawa130.com/image-20220621171031249.png)

   + 修改多个元组的值

     ![image-20220621171041685](https://img.hawa130.com/image-20220621171041685.png)

   + 带子查询的修改语句

     ![image-20220621171059422](https://img.hawa130.com/image-20220621171059422.png)

3. 删除数据（DELETE 只删除表的数据，不删除表的定义）

   + 语法

     ```sql
     DELETE FROM <表名> 
     [WHERE <条件>] ;
     ```

     + WHERE 子句
       + 指定要删除的元组
       + 缺省表示要修改表中的所有元组

   + 删除某一个元组的值

     ![image-20220621171224247](https://img.hawa130.com/image-20220621171224247.png)

   + 删除多个元组的值

     ![image-20220621171233737](https://img.hawa130.com/image-20220621171233737.png)

   + 带子查询的删除语句

     ![image-20220621171244026](https://img.hawa130.com/image-20220621171244026.png)

### 空值的处理

1. 空值的判断：is null，is not null

   ![image-20220621171342883](https://img.hawa130.com/image-20220621171342883.png)

2. 空值的约束条件

   + 有 NOT NULL 约束条件的不能取空值
   + 加了 UNIQUE 限制的属性不能取空值
   + 码属性不能取空值

3. 空值的运算

   + 算术运算：空值与另一个值（包括另一个空值）的算术运算的结果为空值
   + 比较运算：空值与另一个值（包括另一个空值）的比较运算的结果为 UNKNOWN
   + 逻辑运算：
   + 有 UNKNOWN 后，传统二值（TRUE，FALSE）逻辑就扩展成了三值逻辑

### 视图

1. 是一个虚表

2. 对应三级模式的外模式

3. 定义视图

   + 建立视图

     ```sql
     CREATE VIEW <视图名> [(<列名> [，<列名>]…)] 
     AS <子查询> 
     [WITH CHECK OPTION]；
     ```

     + CREATE VIEW 子句中的列名可以省略，此时视图的属性由子查询中 SELECT 目标列中的诸字段组成。但在下列情况下明确指定视图的所有列名：
       + 某个目标列是集函数或列表达式
       +  多表连接时选出了几个同名列作为视图的字段 
       +  需要在视图中为某个列启用新的更合适的名字 
     + 子查询中的属性列不允许定义别名，不允许含有 ORDER BY 子句和 DISTINCT 短语。 
     + WITH CHECK OPTION 表示对视图进行更新操作的数据必须满足视图定义的谓词条件(子查询的条件表达式)。

     ![image-20220621172346205](https://img.hawa130.com/image-20220621172346205.png)

     ![image-20220621172712431](https://img.hawa130.com/image-20220621172712431.png)

   + 删除视图

     ```sql
     DROP VIEW <视图名> [CASCADE] ;
     ```

     

3. 查询视图

   + 和基本表一样

     + 如果该视图导出了其他视图，则使用CASCADE级联删除，或者先显式删除导出的视图，再删除该视图； 
     + 删除基表时，由该基表导出的所有视图定义都必须显式删除。

   + DBMS 实现视图查询的方法

     + 实体化视图

       ![image-20220621173213485](https://img.hawa130.com/image-20220621173213485.png)

     + 视图消解法

       ![image-20220621173236936](https://img.hawa130.com/image-20220621173236936.png)

3. 更新视图

   + 插入 INSERT
   + 删除 DELETE
   + 修改 UPDATE

   ![image-20220621173432673](https://img.hawa130.com/image-20220621173432673.png)

4. 视图的作用
   + 简化用户的操作
   + 使用户能以多种角度看待同一数据
   + 对重构数据库提供了一定程度的逻辑独立性
   + 对机密数据提供安全保护

## 第四章 数据库安全性

### 定义

是指保护数据库以防止不合法使用所造成的数据泄露,更改和破坏

### 不安全因素

1. 非授权用户对数据库的恶意存取和破坏
2. 数据库中重要或敏感数据被泄露
3. 安全环境的脆弱性

### 数据库的安全性控制

1. 用户身份鉴别

   + 每个用户由用户名 username 和用户标识号 UID 组成
   + 常用的用户身份鉴别方法
     + 静态口令鉴别：用户名和密码
     + 动态口令鉴别：短信验证码
     + 生物特征识别：指纹,声纹,虹膜
     + 智能卡鉴别

2. 存取控制

   + 存取控制机制主要包括定义用户权限和合法权限检查两部分

   + 自主存取控制 DAC

     + 用户权限由两个要素组成：数据库对象和操作类型

     + 授权：授予和收回

       + 授权

         ```sql
         grant<权限>on<对象类型><对象名>to<用户>
         ```

       + 收回

         ```sql
         revoke<权限>on<对象类型><对象名>from<用户>
         ```

       + with grant option 子句使得获得某种权限的用户把权限再授予其他用户

     + 数据库角色

       + 定义：是被命名的一组与数据库操作相关的权限，是权限的集合

       + 使用

         + 角色的创建：

           ```sql
           Create Role<角色名>
           ```

         + 给角色授权：

           ```sql
           Grant<权限>on<对象类型><对象名>to<角色名>
           ```

         + 将一个角色授予其他的角色或用户

           ```sql
           Grant<角色1>,...to<角色3>,<用户1>
           ```

         + 角色的收回

           ```sql
           revoke<权限>on<对象类型><对象名>from<角色>
           ```

     + 自主存取控制，仅仅通过对数据的存取权限来进行安全控制，而数据本身并无安全性标记

   + 强制存取控制 MAC

     + 全部实体分为主体和客体
       + 主体是系统中活动实体，实际用户和各进程
       + 客体是系统中被动实体，包括文件、基本表、索引、视图等
       + 对于主体和客体，DBMS 为每个实例（值）指派一个敏感度标记
       + 敏感度标记被分为若干级别：绝密、机密、可信、公开
       + 主体的敏感度标记称为许可证级别，客体的敏感度级别称为密级
     + 主体对任何客体的存取需遵循的规则
       + 仅当主体的许可证级别大于或等于客体的密级，该主体才能读取相应的客体
       + 仅当主体的许可证级别小于或等于客体的密级，该主体才能写相应的客体]

3. 视图控制：为不同用户定义不同的视图，把数据库对象限制在一定范围内

4. 审计功能

5. 数据加密存储和加密传输

## 第五章

### 定义

是指数据的正确性和相容性

### 实体完整性

### 参照完整性

### 用户定义的完整性

### 完整性约束命名子句

1. 在创建表时，可以增加、删除一个完整性约束条件

   ```sql
   CONSTRAINT<完整性约束条件名><完整性约束条件>
   ```

2. 修改表中的完整性约束限制

   ```sql
   ALTER TABLE表名 
   Drop Constraint<完整性约束条件>
   
   ALTER TABLE表名 
   ADD Constraint<完整性约束条件><CHECK短语>
   ```
   
   
